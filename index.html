<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <title>Tezos NFT Tracker</title>
    <script src="https://unpkg.com/@airgap/beacon-sdk@4.2.2/dist/walletbeacon.min.js" onload="console.log('Beacon SDK script loaded')" onerror="console.error('Failed to load Beacon SDK script')"></script>
    <style>
        body { font-family: sans-serif; margin: 0; padding: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #007bff; }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px;
            cursor: pointer; font-size: 16px; margin: 5px 0;
        }
        button:hover { background-color: #0056b3; }
        #walletInfo { margin-bottom: 20px; padding: 10px; background-color: #e9ecef; border-radius: 4px; }
        .nft-list, .offers-list { list-style-type: none; padding: 0; }
        .nft-item, .offer-item {
            display: flex; align-items: center; border: 1px solid #ddd; margin-bottom: 10px;
            padding: 10px; border-radius: 4px; background-color: #f9f9f9;
            flex-wrap: wrap; /* For responsiveness */
        }
        .nft-item img, .offer-item img {
            width: 60px; height: 60px; object-fit: cover; border-radius: 4px; margin-right: 15px;
        }
        .nft-details, .offer-details { flex-grow: 1; font-size: 0.9em; }
        .nft-details p, .offer-details p { margin: 3px 0; }
        .profit { color: green; }
        .loss { color: red; }
        .offer-grade { font-weight: bold; padding: 5px; border-radius: 3px; text-align: center; min-width: 80px; }
        .grade-great { background-color: #28a745; color: white; }
        .grade-fair { background-color: #ffc107; color: black; }
        .grade-lowball { background-color: #dc3545; color: white; }
        .compact-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; }
        .compact-table th, .compact-table td {
            border: 1px solid #ddd; padding: 6px; text-align: left;
            white-space: nowrap; /* Prevent line breaks in cells initially */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        .compact-table th { background-color: #007bff; color: white; }
        .compact-table img { width: 50px; height: 50px; object-fit: cover; border-radius: 3px; vertical-align: middle; }
        .compact-table .image-col { width: 60px; max-width: 60px; }
        .compact-table .details-col { width: 180px; max-width: 180px; }
        .compact-table .own-col { width: 60px; max-width: 60px; text-align: center; }
        .compact-table .price-col { width: 100px; max-width: 100px; }
        .compact-table .links-col { width: 60px; max-width: 60px; text-align: center; }
        .price-display { line-height: 1.2; }
        .price-usd { font-size: 0.8em; color: #666; }
        .artist-name { font-size: 0.8em; color: #666; }
        .details-display { line-height: 1.2; }
        .nft-title { font-size: 1em; font-weight: normal; }
        .artist-name { font-size: 0.8em; color: #666; }
        .info-icon { cursor: pointer; background: none; border: none; font-size: 16px; color: #007bff; padding: 2px; margin-right: 5px; }
        .info-icon:hover { color: #0056b3; }
        .objkt-link { cursor: pointer; background: none; border: none; font-size: 14px; color: #28a745; padding: 2px; }
        .objkt-link:hover { color: #1e7e34; }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px; /* Half of width */
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Allow text to wrap in tooltip */
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        #filters { margin-bottom: 15px; }
        #filters input, #filters select { padding: 8px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }
        .loading { text-align: center; padding: 20px; font-size: 1.2em; }
        
        /* Progress Bar Styles */
        .progress-container { width: 100%; background-color: #f0f0f0; border-radius: 8px; margin: 15px 0; }
        .progress-bar { height: 20px; background-color: #007bff; border-radius: 8px; transition: width 0.3s ease; }
        .progress-text { text-align: center; margin: 10px 0; font-size: 0.9em; color: #666; }
        .progress-details { text-align: center; font-size: 0.8em; color: #888; margin-top: 5px; }
        
        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { 
            background-color: #fefefe; margin: 2% auto; padding: 20px; border-radius: 8px; 
            width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover, .close:focus { color: black; text-decoration: none; }
        .modal-header { display: flex; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
        .modal-image { width: 200px; height: 200px; object-fit: cover; border-radius: 8px; margin-right: 20px; }
        .modal-nft-info { flex: 1; }
        .modal-nft-info h3 { margin: 0 0 10px 0; color: #007bff; }
        .nft-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 20px; }
        .stat-item { background-color: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center; display: flex; flex-direction: column; justify-content: space-between; }
        .stat-value { font-weight: 600; font-size: 1.1em; color: #007bff; }
        .stat-label { font-size: 0.85em; color: #666; font-weight: 300; margin-top: auto; }
        .ownership-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .ownership-table th, .ownership-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .ownership-table th { background-color: #007bff; color: white; }
        .ownership-table .status-owned { color: #28a745; font-weight: bold; }
        .ownership-table .status-sold { color: #dc3545; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tezos NFT Tracker</h1>

        <div id="walletSection">
            <button id="connectWalletBtn">Connect Temple Wallet</button>
            <div id="walletInfo" style="display:none;">
                <p><strong>Address:</strong> <span id="userAddress"></span></p>
                <button id="disconnectWalletBtn">Disconnect Wallet</button>
            </div>
        </div>

        <div id="nftCollectionSection" style="display:none;">
            <h2>My NFT Collection</h2>
            
            <!-- Collection Insights -->
            <div class="nft-stats" id="collectionStats">
                <div class="stat-item">
                    <div class="stat-value" id="totalNFTs">--</div>
                    <div class="stat-label">Total NFTs</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalArtists">--</div>
                    <div class="stat-label">Total Artists</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalSpent">--</div>
                    <div class="stat-label">Total Spent</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="profitLoss">--</div>
                    <div class="stat-label">P/L (Sold)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="collectionEstimate">--</div>
                    <div class="stat-label">Collection Est.</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgPurchasePrice">--</div>
                    <div class="stat-label">Avg Purchase</div>
                </div>
            </div>
            
            <div id="filters">
                <input type="text" id="filterName" placeholder="Filter by name...">
                <select id="sortOptions">
                    <option value="purchaseDateDesc">Sort by Purchase Date (Newest)</option>
                    <option value="purchaseDateAsc">Sort by Purchase Date (Oldest)</option>
                    <option value="nameAsc">Sort by Name (A-Z)</option>
                    <option value="nameDesc">Sort by Name (Z-A)</option>
                </select>
            </div>
            <div id="nftLoading" class="loading" style="display:none;">
                <div>Loading Your NFT Collection...</div>
                <div class="progress-container">
                    <div id="nftProgressBar" class="progress-bar" style="width: 0%;"></div>
                </div>
                <div id="nftProgressText" class="progress-text">Initializing...</div>
                <div id="nftProgressDetails" class="progress-details"></div>
            </div>
            <table class="compact-table">
                <thead>
                    <tr>
                        <th class="image-col">Image</th>
                        <th class="details-col">Details</th>
                        <th class="own-col">Own</th>
                        <th class="price-col">Purchase Price</th>
                        <th class="price-col">Sold Price</th>
                        <th class="price-col">P/L (XTZ)</th>
                        <th class="price-col">P/L (USD)</th>
                        <th class="links-col">Links</th>
                    </tr>
                </thead>
                <tbody id="nftListBody">
                    <!-- NFT items will be injected here -->
                </tbody>
            </table>
            <p><em>Note: Purchase/sale prices and P/L are illustrative for this MVP. Full history requires deeper integration.</em></p>
        </div>

        <div id="offersSection" style="display:none;">
            <h2>Incoming Offers</h2>
            <div id="offersLoading" class="loading" style="display:none;">Loading offers...</div>
            <table class="compact-table">
                <thead>
                    <tr>
                        <th>NFT</th>
                        <th>Offer (XTZ)</th>
                        <th>Offer (USD now)</th>
                        <th>My Purchase (XTZ)</th>
                        <th>Artist Avg. Sale (XTZ)</th>
                        <th>Grade</th>
                    </tr>
                </thead>
                <tbody id="offersListBody">
                    <!-- Offer items will be injected here -->
                </tbody>
            </table>
             <p><em>Note: Offers and artist data are simulated for this MVP.</em></p>
        </div>
        
        <!-- NFT Details Modal -->
        <div id="nftModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeNFTModal()">&times;</span>
                <div class="modal-header">
                    <img id="modalImage" class="modal-image" src="" alt="">
                    <div class="modal-nft-info">
                        <h3 id="modalTitle"></h3>
                        <p><strong>Artist:</strong> <span id="modalArtist"></span></p>
                        <p><strong>Contract:</strong> <span id="modalContract"></span></p>
                        <p><strong>Token ID:</strong> <span id="modalTokenId"></span></p>
                    </div>
                </div>
                
                <div class="nft-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="modalTopSale">--</div>
                        <div class="stat-label">Top Sale</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="modalFloorPrice">--</div>
                        <div class="stat-label">Floor Price</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="modalLastSale">--</div>
                        <div class="stat-label">Last Sale</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="modalMintDate">--</div>
                        <div class="stat-label">Mint Date</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="modalEditions">--</div>
                        <div class="stat-label">Total Editions</div>
                    </div>
                </div>
                
                <h4>Ownership Details</h4>
                <table class="ownership-table">
                    <thead>
                        <tr>
                            <th>Edition #</th>
                            <th>Status</th>
                            <th>Purchase Date</th>
                            <th>Purchase Price</th>
                            <th>Sale Date</th>
                            <th>Sale Price</th>
                        </tr>
                    </thead>
                    <tbody id="modalOwnershipBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Wait for Beacon SDK to load
        let wallet;
        let walletInitialized = false;
        
        function initializeWallet() {
            if (walletInitialized) {
                console.log('Wallet already initialized, reusing existing instance');
                return true;
            }
            
            if (window.beacon && window.beacon.DAppClient) {
                try {
                    const { DAppClient, NetworkType, BeaconEvent } = window.beacon;
                    wallet = new DAppClient({
                        name: 'Tezos NFT Tracker MVP',
                        preferredNetwork: NetworkType.MAINNET,
                        enableMetrics: false
                    });
                    
                    // Subscribe to account events to prevent warnings
                    wallet.subscribeToEvent(BeaconEvent.ACTIVE_ACCOUNT_SET, (account) => {
                        console.log('Active account set:', account);
                    });
                    
                    walletInitialized = true;
                    console.log('Wallet initialized successfully');
                    return true;
                } catch (error) {
                    console.error('Error initializing wallet:', error);
                    return false;
                }
            }
            console.warn('Beacon SDK not available for wallet initialization');
            return false;
        }

        const TZKT_API_BASE = 'https://api.tzkt.io/v1'; // Mainnet
        // const TZKT_API_BASE = 'https://api.ghostnet.tzkt.io/v1'; // Ghostnet

        const COINGECKO_API_BASE = 'https://api.coingecko.com/api/v3';

        // UI Elements
        const connectWalletBtn = document.getElementById('connectWalletBtn');
        const disconnectWalletBtn = document.getElementById('disconnectWalletBtn');
        const walletInfoDiv = document.getElementById('walletInfo');
        const userAddressSpan = document.getElementById('userAddress');
        const nftCollectionSection = document.getElementById('nftCollectionSection');
        const offersSection = document.getElementById('offersSection');
        const nftListBody = document.getElementById('nftListBody');
        const offersListBody = document.getElementById('offersListBody');
        const nftLoading = document.getElementById('nftLoading');
        const offersLoading = document.getElementById('offersLoading');
        const nftProgressBar = document.getElementById('nftProgressBar');
        const nftProgressText = document.getElementById('nftProgressText');
        const nftProgressDetails = document.getElementById('nftProgressDetails');
        const filterNameInput = document.getElementById('filterName');
        const sortOptionsSelect = document.getElementById('sortOptions');

        let userAccount = null;
        let allFetchedNfts = []; // To store all NFTs for filtering/sorting

        // --- Wallet Logic ---
        connectWalletBtn.addEventListener('click', async () => {
            try {
                if (!initializeWallet()) {
                    throw new Error('Beacon SDK not loaded yet. Please wait and try again.');
                }
                await wallet.requestPermissions({
                    network: { type: window.beacon.NetworkType.MAINNET } // or GHOSTNET
                });
                userAccount = await wallet.getActiveAccount();
                if (userAccount) {
                    localStorage.setItem('tezosWalletAddress', userAccount.address);
                    updateWalletUI(userAccount.address);
                    fetchAllData(userAccount.address);
                }
            } catch (error) {
                console.error('Wallet connection failed:', error);
                alert('Failed to connect wallet. See console for details.');
            }
        });

        disconnectWalletBtn.addEventListener('click', async () => {
            if (wallet) {
                await wallet.clearActiveAccount();
            }
            localStorage.removeItem('tezosWalletAddress');
            userAccount = null;
            updateWalletUI(null);
        });

        function updateWalletUI(address) {
            if (address) {
                userAddressSpan.textContent = address;
                walletInfoDiv.style.display = 'block';
                connectWalletBtn.style.display = 'none';
                nftCollectionSection.style.display = 'block';
                offersSection.style.display = 'block';
            } else {
                walletInfoDiv.style.display = 'none';
                connectWalletBtn.style.display = 'block';
                nftCollectionSection.style.display = 'none';
                offersSection.style.display = 'none';
                nftListBody.innerHTML = '';
                offersListBody.innerHTML = '';
                allFetchedNfts = [];
            }
        }

        // --- Data Fetching & Processing ---
        // Function to update progress bar
        function updateProgress(current, total, stage = '', details = '') {
            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
            nftProgressBar.style.width = `${percentage}%`;
            nftProgressText.textContent = `${stage} ${current}/${total} (${percentage}%)`;
            nftProgressDetails.textContent = details;
        }
        
        // Function to fetch all NFT balances with batching and progress tracking
        async function fetchAllNFTBalances(address) {
            const limit = 1000; // API limit per request
            let allBalances = [];
            let offset = 0;
            let hasMore = true;
            let batchNumber = 1;
            
            updateProgress(0, 1, 'Initializing', 'Starting NFT collection fetch...');
            console.log('Starting to fetch NFT collection with batching...');
            
            while (hasMore) {
                try {
                    updateProgress(0, 1, 'Fetching batch', `Loading batch ${batchNumber}...`);
                    
                    const response = await fetch(`${TZKT_API_BASE}/tokens/balances?account=${address}&token.standard=fa2&balance.gt=0&limit=${limit}&offset=${offset}&select=token,balance,firstLevel,lastLevel,firstTime,lastTime`);
                    if (!response.ok) throw new Error(`Failed to fetch NFT balances: ${response.statusText}`);
                    
                    const batch = await response.json();
                    allBalances = allBalances.concat(batch);
                    
                    console.log(`Fetched batch ${batchNumber}: ${batch.length} NFTs (total so far: ${allBalances.length})`);
                    updateProgress(allBalances.length, allBalances.length + (hasMore ? 1000 : 0), 'Collected', `${allBalances.length} NFTs found`);
                    
                    // Check if we got a full batch (indicating there might be more)
                    hasMore = batch.length === limit;
                    offset += limit;
                    batchNumber++;
                    
                    // Small delay to be respectful to the API
                    if (hasMore) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (error) {
                    console.error(`Error fetching batch at offset ${offset}:`, error);
                    throw error;
                }
            }
            
            updateProgress(allBalances.length, allBalances.length, 'Collection loaded', `${allBalances.length} total NFTs`);
            console.log(`Finished fetching NFT collection: ${allBalances.length} total NFTs`);
            return allBalances;
        }

        async function fetchAllData(address) {
            nftLoading.style.display = 'block';
            offersLoading.style.display = 'block';
            nftListBody.innerHTML = ''; // Clear previous
            offersListBody.innerHTML = ''; // Clear previous

            try {
                const currentXTZPrice = await getRealTimeXTZPrice(); // For offer USD value

                // 1. Fetch NFTs currently owned with batching to handle large collections
                // We'll focus on tokens the user currently holds (balances > 0)
                // For "all ever purchased", we'd need to parse all 'transfers' where user is 'to'
                const balances = await fetchAllNFTBalances(address);
                
                console.log("Fetched balances:", balances);

                allFetchedNfts = []; // Reset
                
                // First, prepare all NFT data without price calculations
                const nftDataPrep = [];
                for (const item of balances) {
                    if (!item.token || !item.token.metadata) {
                        console.warn("Skipping token with missing metadata:", item);
                        continue;
                    }
                    const metadata = item.token.metadata;
                    
                    // Use actual firstTime from API for purchase date, or simulate a realistic historical date
                    let purchaseTimestamp;
                    if (item.firstTime) {
                        purchaseTimestamp = item.firstTime; // Already an ISO string from API
                    } else {
                        // Simulate a purchase date between 6 months and 2 years ago
                        const daysAgo = Math.floor(Math.random() * 548) + 180; // 180-728 days ago
                        purchaseTimestamp = new Date(Date.now() - (daysAgo * 24 * 60 * 60 * 1000)).toISOString();
                    }
                    
                    // SIMULATE purchase price - this is a huge simplification
                    const simulatedPurchasePriceXTZ = (Math.random() * 10 + 1).toFixed(2); // Random 1-11 XTZ
                    
                    // SIMULATE if sold (very unlikely for currently owned, but for demo)
                    const isSold = Math.random() > 0.8; // 20% chance it was "sold" and rebought (for demo)
                    let simulatedSalePriceXTZ = null;
                    let saleTimestamp = null;

                    if (isSold) {
                        simulatedSalePriceXTZ = (Math.random() * 15 + 0.5).toFixed(2);
                        // Simulate sale date as 30-120 days after purchase
                        const purchaseDate = new Date(purchaseTimestamp);
                        const daysAfterPurchase = Math.floor(Math.random() * 90) + 30;
                        saleTimestamp = new Date(purchaseDate.getTime() + (daysAfterPurchase * 24 * 60 * 60 * 1000)).toISOString();
                    }
                    
                    nftDataPrep.push({
                        item,
                        metadata,
                        purchaseTimestamp,
                        simulatedPurchasePriceXTZ,
                        isSold,
                        simulatedSalePriceXTZ,
                        saleTimestamp
                    });
                }
                
                console.log(`Processing ${nftDataPrep.length} NFTs with price calculations...`);
                updateProgress(0, nftDataPrep.length, 'Calculating prices', 'Preparing to calculate historical USD prices...');
                
                // Now process in batches to avoid overwhelming the price API
                const batchSize = 20;
                const totalBatches = Math.ceil(nftDataPrep.length / batchSize);
                
                for (let i = 0; i < nftDataPrep.length; i += batchSize) {
                    const batch = nftDataPrep.slice(i, i + batchSize);
                    const currentBatch = Math.floor(i/batchSize) + 1;
                    
                    console.log(`Processing price batch ${currentBatch}/${totalBatches}`);
                    updateProgress(i, nftDataPrep.length, 'Calculating prices', `Processing batch ${currentBatch}/${totalBatches} - calculating USD values...`);
                    
                    // Process batch with small delay
                    const batchPromises = batch.map(async (nftData) => {
                        const { item, metadata, purchaseTimestamp, simulatedPurchasePriceXTZ, isSold, simulatedSalePriceXTZ, saleTimestamp } = nftData;
                        
                        const purchasePriceUSD = await getHistoricalXTZPrice(purchaseTimestamp);
                        const simulatedPurchasePriceUSD = purchasePriceUSD ? (simulatedPurchasePriceXTZ * purchasePriceUSD).toFixed(2) : 'N/A';
                        
                        let simulatedSalePriceUSD = null;
                        let profitLossXTZ = null;
                        let profitLossUSD = null;
                        
                        if (isSold && saleTimestamp) {
                            const salePriceUSDHistorical = await getHistoricalXTZPrice(saleTimestamp);
                            simulatedSalePriceUSD = salePriceUSDHistorical ? (simulatedSalePriceXTZ * salePriceUSDHistorical).toFixed(2) : 'N/A';
                            
                            profitLossXTZ = (simulatedSalePriceXTZ - simulatedPurchasePriceXTZ).toFixed(2);
                            if (purchasePriceUSD && salePriceUSDHistorical) {
                                 profitLossUSD = ((simulatedSalePriceXTZ * salePriceUSDHistorical) - (simulatedPurchasePriceXTZ * purchasePriceUSD)).toFixed(2);
                            }
                        }
                        
                        return {
                            id: `${item.token.contract.address}_${item.token.tokenId}`,
                            name: metadata.name || `Token ${item.token.tokenId}`,
                            image: normalizeIpfsUrl(metadata.displayUri || metadata.thumbnailUri || metadata.artifactUri),
                            quantity: item.balance,
                            purchasePriceXTZ: simulatedPurchasePriceXTZ,
                            purchasePriceUSD: simulatedPurchasePriceUSD,
                            purchaseDate: purchaseTimestamp,
                            salePriceXTZ: isSold ? simulatedSalePriceXTZ : null,
                            salePriceUSD: isSold ? simulatedSalePriceUSD : null,
                            saleDate: saleTimestamp,
                            profitLossXTZ: profitLossXTZ,
                            profitLossUSD: profitLossUSD,
                            artistAddress: item.token.contract.address,
                            artistName: null,
                            tokenId: item.token.tokenId,
                            contractAddress: item.token.contract.address
                        };
                    });
                    
                    const batchResults = await Promise.all(batchPromises);
                    allFetchedNfts.push(...batchResults);
                    
                    // Update progress after each batch
                    const processedCount = Math.min(i + batchSize, nftDataPrep.length);
                    updateProgress(processedCount, nftDataPrep.length, 'Calculating prices', `Processed ${processedCount}/${nftDataPrep.length} NFTs`);
                    
                    // Small delay between batches to be nice to APIs
                    if (i + batchSize < nftDataPrep.length) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
                
                updateProgress(nftDataPrep.length, nftDataPrep.length, 'Processing complete', 'Finalizing your NFT collection...');
                
                updateProgress(100, 100, 'Rendering', 'Displaying your NFT collection...');
                renderNFTs(); // Initial render with default sort
                
                // Fetch artist names from Objkt and re-render
                updateProgress(0, 100, 'Loading artists', 'Fetching artist information...');
                await fetchArtistNames(allFetchedNfts);
                updateProgress(100, 100, 'Artists loaded', 'Artist information updated');
                renderNFTs(); // Re-render with artist names
                
                updateProgress(0, 100, 'Generating offers', 'Creating simulated offers...');
                await generateSimulatedOffers(allFetchedNfts, currentXTZPrice);
                updateProgress(100, 100, 'Complete', 'All data loaded successfully!');

            } catch (error) {
                console.error('Error fetching data:', error);
                nftListBody.innerHTML = `<tr><td colspan="8">Error loading NFTs: ${error.message}</td></tr>`;
                offersListBody.innerHTML = `<tr><td colspan="6">Error loading offers: ${error.message}</td></tr>`;
            } finally {
                // Add a small delay before hiding the progress bar so user can see completion
                setTimeout(() => {
                    nftLoading.style.display = 'none';
                    offersLoading.style.display = 'none';
                }, 1000);
            }
        }

        async function fetchArtistNames(nfts) {
            // CACHE BUST: Updated 2025-01-06 - No more GraphQL calls!
            console.log('Setting up artist names for', nfts.length, 'NFTs...');
            
            // For now, let's use a simpler approach to avoid API overload
            // We'll just use contract addresses as artist identifiers
            for (const nft of nfts) {
                // Set a default artist name based on contract address
                nft.artistName = nft.contractAddress.substring(0, 8) + '...';
            }
            
            // TODO: Implement proper artist name fetching in batches
            // For MVP, showing contract addresses is sufficient
            console.log('Artist names set to contract addresses for stability');
            
            // NO FETCH CALLS HERE - removed all API calls to prevent errors
        }

        // Historical price lookup with fallback values for localhost/CORS issues
        const HISTORICAL_XTZ_PRICES = {
            '2022': 1.50,  // Average XTZ price in 2022
            '2023': 0.80,  // Average XTZ price in 2023  
            '2024': 1.20,  // Average XTZ price in 2024
            '2025': 0.90   // Current estimate for 2025
        };
        
        async function getHistoricalXTZPrice(isoTimestamp) {
            try {
                const date = new Date(isoTimestamp);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                const dateString = `${day}-${month}-${year}`;
                
                // Check cache first
                const cacheKey = `xtz_price_${dateString}`;
                const cachedPrice = localStorage.getItem(cacheKey);
                if (cachedPrice) return parseFloat(cachedPrice);
                
                // For localhost development, use fallback prices to avoid CORS
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    const yearPrice = HISTORICAL_XTZ_PRICES[year.toString()] || HISTORICAL_XTZ_PRICES['2024'];
                    // Add some random variation (+/- 20%) to make it more realistic
                    const variation = 0.8 + (Math.random() * 0.4);
                    const price = yearPrice * variation;
                    localStorage.setItem(cacheKey, price.toString());
                    return price;
                }
                
                // For production, try the API (but with better error handling)
                try {
                    const response = await fetch(`${COINGECKO_API_BASE}/coins/tezos/history?date=${dateString}&localization=false`);
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    const data = await response.json();
                    if (data.market_data && data.market_data.current_price && data.market_data.current_price.usd) {
                        localStorage.setItem(cacheKey, data.market_data.current_price.usd);
                        return data.market_data.current_price.usd;
                    }
                } catch (apiError) {
                    console.warn(`CoinGecko API failed for ${dateString}, using fallback price`);
                }
                
                // Fallback to estimated historical prices
                const yearPrice = HISTORICAL_XTZ_PRICES[year.toString()] || HISTORICAL_XTZ_PRICES['2024'];
                const variation = 0.8 + (Math.random() * 0.4);
                const price = yearPrice * variation;
                localStorage.setItem(cacheKey, price.toString());
                return price;
                
            } catch (error) {
                console.error('Error in getHistoricalXTZPrice:', error);
                // Final fallback
                return 1.20;
            }
        }

        async function getRealTimeXTZPrice() {
            try {
                const cacheKey = 'xtz_current_price';
                const cached = JSON.parse(localStorage.getItem(cacheKey) || '{}');
                if (cached.price && (Date.now() - cached.timestamp < 5 * 60 * 1000)) { // Cache for 5 mins
                    return cached.price;
                }
                
                // For localhost, use fallback price
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    const fallbackPrice = 0.90; // Current estimated XTZ price
                    localStorage.setItem(cacheKey, JSON.stringify({price: fallbackPrice, timestamp: Date.now()}));
                    return fallbackPrice;
                }

                // For production, try the API
                try {
                    const response = await fetch(`${COINGECKO_API_BASE}/simple/price?ids=tezos&vs_currencies=usd`);
                    if (!response.ok) throw new Error('Failed to fetch current XTZ price');
                    const data = await response.json();
                    const price = data.tezos.usd;
                    localStorage.setItem(cacheKey, JSON.stringify({price: price, timestamp: Date.now()}));
                    return price;
                } catch (apiError) {
                    console.warn('CoinGecko API failed for current price, using fallback');
                    const fallbackPrice = 0.90;
                    localStorage.setItem(cacheKey, JSON.stringify({price: fallbackPrice, timestamp: Date.now()}));
                    return fallbackPrice;
                }
            } catch (error) {
                console.error('Error fetching real-time XTZ price:', error);
                return 0.90; // Fallback price
            }
        }

        function normalizeIpfsUrl(uri) {
            if (!uri) return 'https://via.placeholder.com/60?text=No+Art';
            if (uri.startsWith('ipfs://')) {
                return `https://ipfs.io/ipfs/${uri.substring(7)}`;
            }
            // Handle other common gateway links or direct HTTPS if necessary
            if (uri.startsWith('https://gateway.pinata.cloud/ipfs/')) return uri;
            if (uri.startsWith('https://cloudflare-ipfs.com/ipfs/')) return uri;
            // Add more known gateways if needed
            return uri; // Assume it's a direct HTTP/HTTPS URL
        }
        
        function updateCollectionStats() {
            if (allFetchedNfts.length === 0) {
                document.getElementById('totalNFTs').textContent = '--';
                document.getElementById('totalSpent').innerHTML = '--';
                document.getElementById('totalArtists').textContent = '--';
                document.getElementById('profitLoss').innerHTML = '--';
                document.getElementById('collectionEstimate').innerHTML = '--';
                document.getElementById('avgPurchasePrice').innerHTML = '--';
                return;
            }

            // Calculate totals
            const totalNFTs = allFetchedNfts.length;
            const totalSpentXTZ = allFetchedNfts.reduce((sum, nft) => sum + parseFloat(nft.purchasePriceXTZ || 0), 0);
            const totalSpentUSD = allFetchedNfts.reduce((sum, nft) => sum + parseFloat(nft.purchasePriceUSD || 0), 0);
            
            // Count unique artists
            const uniqueArtists = new Set(allFetchedNfts.map(nft => nft.artistName || nft.contractAddress)).size;
            
            // Calculate P/L for sold items only
            const soldNFTs = allFetchedNfts.filter(nft => nft.salePriceXTZ !== null);
            const profitLossXTZ = soldNFTs.reduce((sum, nft) => sum + parseFloat(nft.profitLossXTZ || 0), 0);
            const profitLossUSD = soldNFTs.reduce((sum, nft) => sum + parseFloat(nft.profitLossUSD || 0), 0);
            
            // Calculate average purchase price
            const avgPurchasePrice = totalSpentXTZ / totalNFTs;
            
            // Estimate collection value (simplified: avg purchase price * total NFTs * random market factor)
            const marketFactor = 0.8 + Math.random() * 0.4; // 0.8x to 1.2x of purchase prices
            const collectionEstimate = avgPurchasePrice * totalNFTs * marketFactor;
            const collectionEstimateUSD = collectionEstimate * 1.20; // Rough current XTZ price estimate

            // Update the display with combined XTZ/USD format
            document.getElementById('totalNFTs').textContent = totalNFTs.toString();
            
            document.getElementById('totalSpent').innerHTML = `${totalSpentXTZ.toFixed(2)} XTZ<br><span class="price-usd">$${totalSpentUSD.toFixed(0)}</span>`;
            
            document.getElementById('totalArtists').textContent = uniqueArtists.toString();
            
            // P/L with color coding and combined format
            const plElement = document.getElementById('profitLoss');
            if (soldNFTs.length > 0) {
                const plXTZText = `${profitLossXTZ >= 0 ? '+' : ''}${profitLossXTZ.toFixed(2)} XTZ`;
                const plUSDText = `${profitLossUSD >= 0 ? '+$' : '-$'}${Math.abs(profitLossUSD).toFixed(0)}`;
                
                plElement.innerHTML = `${plXTZText}<br><span class="price-usd">${plUSDText}</span>`;
                plElement.className = `stat-value ${profitLossXTZ >= 0 ? 'profit' : 'loss'}`;
            } else {
                plElement.innerHTML = 'No Sales<br><span class="price-usd">Yet</span>';
                plElement.className = 'stat-value';
            }
            
            document.getElementById('collectionEstimate').innerHTML = `${collectionEstimate.toFixed(1)} XTZ<br><span class="price-usd">$${collectionEstimateUSD.toFixed(0)}</span>`;
            
            document.getElementById('avgPurchasePrice').innerHTML = `${avgPurchasePrice.toFixed(2)} XTZ<br><span class="price-usd">$${(avgPurchasePrice * 1.20).toFixed(0)}</span>`;
        }

        function renderNFTs() {
            updateCollectionStats(); // Update stats whenever NFTs are rendered
            nftListBody.innerHTML = ''; // Clear previous list

            let filteredNfts = [...allFetchedNfts];
            const filterText = filterNameInput.value.toLowerCase();
            if (filterText) {
                filteredNfts = filteredNfts.filter(nft => nft.name.toLowerCase().includes(filterText));
            }

            const sortValue = sortOptionsSelect.value;
            filteredNfts.sort((a, b) => {
                switch (sortValue) {
                    case 'purchaseDateDesc':
                        return new Date(b.purchaseDate) - new Date(a.purchaseDate);
                    case 'purchaseDateAsc':
                        return new Date(a.purchaseDate) - new Date(b.purchaseDate);
                    case 'nameAsc':
                        return a.name.localeCompare(b.name);
                    case 'nameDesc':
                        return b.name.localeCompare(a.name);
                    default:
                        return 0;
                }
            });

            if (filteredNfts.length === 0) {
                nftListBody.innerHTML = `<tr><td colspan="8">No NFTs found matching your criteria.</td></tr>`;
                return;
            }

            filteredNfts.forEach(nft => {
                const row = nftListBody.insertRow();
                
                // Format purchase price
                const purchasePrice = nft.purchasePriceXTZ !== 'N/A' && nft.purchasePriceUSD !== 'N/A' 
                    ? `<div class="price-display">${nft.purchasePriceXTZ} XTZ<br><span class="price-usd">$${nft.purchasePriceUSD}</span></div>`
                    : 'N/A';
                
                // Format sold price
                const soldPrice = nft.salePriceXTZ 
                    ? `<div class="price-display">${nft.salePriceXTZ} XTZ<br><span class="price-usd">$${nft.salePriceUSD || 'N/A'}</span></div>`
                    : 'Not Sold';
                
                // Format details (name + artist)
                const artistDisplay = nft.artistName || (nft.artistAddress ? nft.artistAddress.substring(0, 8) + '...' : 'Unknown Artist');
                const nftNameDisplay = nft.name.length > 20 ? nft.name.substring(0, 17) + '...' : nft.name;
                const detailsDisplay = `<span class="nft-title">${nftNameDisplay}</span><br><span class="artist-name">${artistDisplay}</span>`;
                
                // Objkt link
                const objktUrl = `https://objkt.com/asset/${nft.contractAddress}/${nft.tokenId}`;
                
                row.innerHTML = `
                    <td class="image-col"><img src="${nft.image}" alt="${nft.name}" title="${nft.name}"></td>
                    <td class="details-col">${detailsDisplay}</td>
                    <td class="own-col">${nft.quantity}</td>
                    <td class="price-col">${purchasePrice}</td>
                    <td class="price-col">${soldPrice}</td>
                    <td class="price-col ${nft.profitLossXTZ > 0 ? 'profit' : nft.profitLossXTZ < 0 ? 'loss' : ''}">${nft.profitLossXTZ !== null ? `${nft.profitLossXTZ} XTZ` : 'N/A'}</td>
                    <td class="price-col ${nft.profitLossUSD > 0 ? 'profit' : nft.profitLossUSD < 0 ? 'loss' : ''}">${nft.profitLossUSD !== null ? `$${nft.profitLossUSD}` : 'N/A'}</td>
                    <td class="links-col">
                        <button class="info-icon" onclick="showNFTDetails('${nft.id}')">‚ÑπÔ∏è</button>
                        <button class="objkt-link" onclick="window.open('${objktUrl}', '_blank')" title="View on Objkt">üîó</button>
                    </td>
                `;
            });
        }

        filterNameInput.addEventListener('input', renderNFTs);
        sortOptionsSelect.addEventListener('change', renderNFTs);

        // Modal functions
        function showNFTDetails(nftId) {
            const nft = allFetchedNfts.find(n => n.id === nftId);
            if (!nft) return;
            
            // Populate modal with NFT data
            document.getElementById('modalImage').src = nft.image;
            document.getElementById('modalTitle').textContent = nft.name;
            document.getElementById('modalArtist').textContent = nft.artistAddress ? 
                nft.artistAddress.substring(0, 8) + '...' : 'Unknown';
            document.getElementById('modalContract').textContent = nft.contractAddress;
            document.getElementById('modalTokenId').textContent = nft.tokenId;
            
            // Simulate NFT stats
            const stats = generateSimulatedNFTStats(nft);
            document.getElementById('modalTopSale').textContent = stats.topSale;
            document.getElementById('modalFloorPrice').textContent = stats.floorPrice;
            document.getElementById('modalLastSale').textContent = stats.lastSale;
            document.getElementById('modalMintDate').textContent = stats.mintDate;
            document.getElementById('modalEditions').textContent = stats.editions;
            
            // Populate ownership table
            populateOwnershipTable(nft);
            
            // Show modal
            document.getElementById('nftModal').style.display = 'block';
        }
        
        function closeNFTModal() {
            document.getElementById('nftModal').style.display = 'none';
        }
        
        function generateSimulatedNFTStats(nft) {
            const basePrice = parseFloat(nft.purchasePriceXTZ) || 5;
            return {
                topSale: `${(basePrice * (1.5 + Math.random())).toFixed(2)} XTZ`,
                floorPrice: `${(basePrice * (0.7 + Math.random() * 0.3)).toFixed(2)} XTZ`,
                lastSale: `${(basePrice * (0.8 + Math.random() * 0.4)).toFixed(2)} XTZ`,
                mintDate: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toLocaleDateString(),
                editions: Math.floor(Math.random() * 100) + 1
            };
        }
        
        function populateOwnershipTable(nft) {
            const tableBody = document.getElementById('modalOwnershipBody');
            tableBody.innerHTML = '';
            
            const quantity = parseInt(nft.quantity);
            const soldCount = nft.salePriceXTZ ? Math.floor(quantity * 0.3) : 0; // Simulate some sold
            
            for (let i = 1; i <= quantity + soldCount; i++) {
                const row = tableBody.insertRow();
                const isSold = i > quantity;
                const status = isSold ? 'Sold' : 'Owned';
                const statusClass = isSold ? 'status-sold' : 'status-owned';
                
                // Use actual dates from the NFT data
                const purchaseDate = new Date(nft.purchaseDate);
                const saleDate = isSold && nft.saleDate ? new Date(nft.saleDate) : null;
                
                // Simulate individual prices (slight variations)
                const purchaseVariation = 0.9 + Math.random() * 0.2;
                const individualPurchasePrice = (parseFloat(nft.purchasePriceXTZ) * purchaseVariation).toFixed(2);
                const individualSalePrice = isSold ? (parseFloat(nft.salePriceXTZ) * (0.9 + Math.random() * 0.2)).toFixed(2) : null;
                
                row.innerHTML = `
                    <td>#${i}</td>
                    <td class="${statusClass}">${status}</td>
                    <td>${purchaseDate.toLocaleDateString()}</td>
                    <td>${individualPurchasePrice} XTZ</td>
                    <td>${saleDate ? saleDate.toLocaleDateString() : '--'}</td>
                    <td>${individualSalePrice ? `${individualSalePrice} XTZ` : '--'}</td>
                `;
            }
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('nftModal');
            if (event.target === modal) {
                closeNFTModal();
            }
        }

        // --- Offers Logic (Simulated) ---
        async function generateSimulatedOffers(nfts, currentXTZPrice) {
            offersListBody.innerHTML = '';
            if (nfts.length === 0) {
                 offersListBody.innerHTML = `<tr><td colspan="6">No NFTs to receive offers on.</td></tr>`;
                 return;
            }

            const offers = [];
            // Simulate offers for a few NFTs
            for (let i = 0; i < Math.min(nfts.length, 5); i++) {
                const nft = nfts[Math.floor(Math.random() * nfts.length)]; // Pick a random NFT

                // SIMULATE artist's other sales data
                const simulatedArtistSales = {
                    averagePriceXTZ: (parseFloat(nft.purchasePriceXTZ) || 5) * (0.8 + Math.random() * 0.4), // +/- 20% of purchase
                    count: Math.floor(Math.random() * 20) + 5
                };

                const offerPriceXTZ = (simulatedArtistSales.averagePriceXTZ * (0.5 + Math.random())).toFixed(2); // 50%-150% of avg
                const offerPriceUSD = currentXTZPrice ? (offerPriceXTZ * currentXTZPrice).toFixed(2) : 'N/A';

                const grade = gradeOffer(parseFloat(offerPriceXTZ), simulatedArtistSales.averagePriceXTZ);

                offers.push({
                    nftName: nft.name,
                    nftImage: nft.image,
                    offerPriceXTZ: offerPriceXTZ,
                    offerPriceUSD: offerPriceUSD,
                    originalPurchaseXTZ: nft.purchasePriceXTZ,
                    artistAvgSaleXTZ: simulatedArtistSales.averagePriceXTZ.toFixed(2),
                    grade: grade.text,
                    gradeClass: grade.class
                });
            }
            renderOffers(offers);
        }

        function renderOffers(offers) {
            offersListBody.innerHTML = '';
            if (offers.length === 0) {
                offersListBody.innerHTML = `<tr><td colspan="6">No current offers.</td></tr>`;
                return;
            }
            offers.forEach(offer => {
                const row = offersListBody.insertRow();
                row.innerHTML = `
                    <td>
                        <img src="${offer.nftImage}" alt="${offer.nftName}" style="width:30px; height:30px; margin-right:5px; vertical-align:middle;">
                        <span class="tooltip">${offer.nftName.length > 15 ? offer.nftName.substring(0, 12) + '...' : offer.nftName}
                            ${offer.nftName.length > 15 ? `<span class="tooltiptext">${offer.nftName}</span>` : ''}
                        </span>
                    </td>
                    <td>${offer.offerPriceXTZ} Tez</td>
                    <td>$${offer.offerPriceUSD}</td>
                    <td>${offer.originalPurchaseXTZ || 'N/A'} Tez</td>
                    <td>${offer.artistAvgSaleXTZ} Tez</td>
                    <td><span class="offer-grade ${offer.gradeClass}">${offer.grade}</span></td>
                `;
            });
        }

        // --- Artist Comparison & Offer Grading (Simulated) ---
        function gradeOffer(offerPriceXTZ, artistTypicalSaleXTZ) {
            if (!artistTypicalSaleXTZ || artistTypicalSaleXTZ === 0) return { text: "N/A", class: "" }; // Cannot grade

            const ratio = offerPriceXTZ / artistTypicalSaleXTZ;
            if (ratio >= 1.1) return { text: "Great", class: "grade-great" };
            if (ratio >= 0.9) return { text: "Fair", class: "grade-fair" };
            return { text: "Lowball", class: "grade-lowball" };
        }

        // --- Initialization ---
        function waitForBeaconSDK() {
            return new Promise((resolve, reject) => {
                console.log('Checking for window.beacon...', !!window.beacon);
                
                if (window.beacon && window.beacon.DAppClient) {
                    console.log('Beacon SDK already available');
                    resolve();
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max
                const checkInterval = setInterval(() => {
                    attempts++;
                    console.log(`Attempt ${attempts}: checking for beacon...`, !!window.beacon);
                    
                    if (window.beacon && window.beacon.DAppClient) {
                        console.log('Beacon SDK found!');
                        clearInterval(checkInterval);
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        console.error('Beacon SDK timeout after', attempts, 'attempts');
                        console.log('Available beacon globals:', Object.keys(window).filter(k => k.toLowerCase().includes('beacon')));
                        clearInterval(checkInterval);
                        reject(new Error('Beacon SDK failed to load'));
                    }
                }, 100);
            });
        }

        async function init() {
            console.log('Starting initialization...');
            console.log('Current window.beacon:', window.beacon);
            
            try {
                console.log('Waiting for Beacon SDK...');
                await waitForBeaconSDK();
                console.log('Beacon SDK loaded successfully');
                
                // Initialize wallet after SDK loads
                const walletReady = initializeWallet();
                if (walletReady) {
                    console.log('Wallet initialization complete');
                    
                    console.log('Wallet ready for connections');
                } else {
                    console.warn('Wallet initialization failed');
                }
                
                // Check if a wallet address was stored from a prior session and auto-reconnect
                const storedAddress = localStorage.getItem('tezosWalletAddress');
                if (storedAddress && walletReady) {
                    console.log("Previously connected address found:", storedAddress, "- attempting auto-reconnect");
                    try {
                        // Try to get the active account without triggering permission request
                        const activeAccount = await wallet.getActiveAccount();
                        if (activeAccount && activeAccount.address === storedAddress) {
                            userAccount = activeAccount;
                            updateWalletUI(activeAccount.address);
                            fetchAllData(activeAccount.address);
                            console.log("Auto-reconnected successfully");
                        } else {
                            // Clear invalid stored address
                            localStorage.removeItem('tezosWalletAddress');
                            console.log("Stored address no longer valid, cleared from storage");
                        }
                    } catch (error) {
                        console.log("Auto-reconnect failed:", error.message, "- user will need to reconnect manually");
                        localStorage.removeItem('tezosWalletAddress');
                    }
                }
            } catch (error) {
                console.error('Failed to initialize Beacon SDK:', error);
                console.log('Trying to proceed without SDK - user can try manual connection');
            }
        }

        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>